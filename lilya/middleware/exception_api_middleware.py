from collections.abc import Callable, Mapping
from typing import Any

from lilya.protocols.middleware import MiddlewareProtocol
from lilya.requests import Request
from lilya.responses import Response
from lilya.types import ASGIApp, Receive, Scope, Send


class LilyaAPIExceptionMiddleware(MiddlewareProtocol):
    """
    Middleware for handling exceptions raised by an ASGI application within Lilya.

    This middleware intercepts HTTP requests and attempts to catch any exceptions
    raised by the downstream ASGI application. If an exception is caught and
    a corresponding handler is registered, it will be invoked to generate
    an appropriate `Response`. If no handler is found for a specific exception
    type, the exception will be re-raised.
    """

    def __init__(
        self,
        app: ASGIApp,
        handlers: Mapping[Any, Callable[[Request, Exception], Response]] | None = None,
    ):
        """
        Initializes the LilyaAPIExceptionMiddleware.

        Args:
            app: The downstream ASGI application callable. This is typically the
                next middleware or the main application handler in the ASGI stack.
            handlers: An optional mapping where keys are exception types and values
                are asynchronous callable handlers. Each handler should accept
                a `Request` and an `Exception` instance, and return a `Response`.
                If no handlers are provided, an empty mapping is used.
        """
        super().__init__(app)
        self.app = app
        self.handlers = handlers or {}

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The ASGI callable method for the middleware.

        This method processes incoming ASGI messages. It only applies exception
        handling logic to `http` scope types. For other scope types (e.g.,
        'websocket', 'lifespan'), it passes the request directly to the
        downstream application. For HTTP requests, it wraps the downstream
        application call in a `try-except` block to catch and handle exceptions.

        Args:
            scope: The ASGI scope dictionary, containing connection information.
            receive: The ASGI receive callable, used to get incoming messages.
            send: The ASGI send callable, used to send outgoing messages.
        """
        if scope["type"] != "http":
            # For other types, pass through to the next application directly.
            return await self.app(scope, receive, send)

        request = Request(scope, receive)
        try:
            await self.app(scope, receive, send)  # noqa
        except Exception as exc:
            # If an exception occurs, try to find a registered handler for its type.
            # We use `type(exc)` to get the exact class of the exception.
            handler = self._lookup_handler(type(exc))
            if handler:
                # If a handler is found, call it with the request and the exception.
                # The handler is expected to return a Lilya Response object.
                response: Response = await handler(request, exc)
                # Send the response generated by the exception handler to the client.
                await response(scope, receive, send)
            else:
                # If no specific handler is found for the exception type, re-raise it.
                # This allows the exception to be caught by higher-level middleware
                # or default ASGI server error handling.
                raise

    def _lookup_handler(
        self, exc_type: type[Exception]
    ) -> Callable[[Request, Exception], Response] | None:
        """
        Looks up a registered exception handler for a given exception type.

        This method performs an exact match lookup for the exception type in
        the registered handlers. More complex lookup strategies (e.g., walking
        the MRO to find handlers for base exception classes) could be added
        here if more flexibility is desired.

        Args:
            exc_type: The type of the exception for which to find a handler.

        Returns:
            The callable handler for the exception type if found, otherwise None.
        """
        # Retrieve the handler directly from the handlers mapping.
        # This performs an exact type match.
        return self.handlers.get(exc_type, None)
